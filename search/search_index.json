{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Design Patterns Documentation","text":"<p>Welcome to the Design Patterns Documentation site. This site contains information about common design patterns implemented in our flight reservation system.</p>"},{"location":"#design-patterns","title":"Design Patterns","text":"<p>This documentation covers five important design patterns:</p> <ol> <li>Strategy Pattern</li> <li>Factory Method Pattern</li> <li>Template Method Pattern</li> <li>Observer Pattern</li> <li>Composite Pattern</li> </ol>"},{"location":"design-smells/design-smell-1/","title":"Strategy Pattern Refactoring","text":"<p>This md details the implementation of the Strategy Pattern in this repository to improve the payment processing mechanism.</p>"},{"location":"design-smells/design-smell-1/#problem-identification","title":"Problem Identification","text":""},{"location":"design-smells/design-smell-1/#original-implementation","title":"Original Implementation","text":"<p>In the original codebase, the payment processing logic was tightly coupled with the <code>FlightOrder</code> class. The class had multiple methods for different payment types:</p> <pre><code>public boolean processOrderWithCreditCard(CreditCard creditCard) throws IllegalStateException {\n    if (isClosed()) {\n        // Payment is already proceeded\n        return true;\n    }\n    // validate payment information\n    if (!cardIsPresentAndValid(creditCard)) {\n        throw new IllegalStateException(\"Payment information is not set or not valid.\");\n    }\n    boolean isPaid = payWithCreditCard(creditCard, this.getPrice());\n    if (isPaid) {\n        this.setClosed();\n    }\n    return isPaid;\n}\n\npublic boolean processOrderWithPayPal(String email, String password) throws IllegalStateException {\n    if (isClosed()) {\n        // Payment is already proceeded\n        return true;\n    }\n    // validate payment information\n    if (email == null || password == null || !email.equals(Paypal.DATA_BASE.get(password))) {\n        throw new IllegalStateException(\"Payment information is not set or not valid.\");\n    }\n    boolean isPaid = payWithPayPal(email, password, this.getPrice());\n    if (isPaid) {\n        this.setClosed();\n    }\n    return isPaid;\n}\n\npublic boolean payWithCreditCard(CreditCard card, double amount) throws IllegalStateException {\n    if (cardIsPresentAndValid(card)) {\n        System.out.println(\"Paying \" + getPrice() + \" using Credit Card.\");\n        double remainingAmount = card.getAmount() - getPrice();\n        if (remainingAmount &lt; 0) {\n            System.out.printf(\"Card limit reached - Balance: %f%n\", remainingAmount);\n            throw new IllegalStateException(\"Card limit reached\");\n        }\n        card.setAmount(remainingAmount);\n        return true;\n    } else {\n        return false;\n    }\n}\n\npublic boolean payWithPayPal(String email, String password, double amount) throws IllegalStateException {\n    if (email.equals(Paypal.DATA_BASE.get(password))) {\n        System.out.println(\"Paying \" + getPrice() + \" using PayPal.\");\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-1/#issues-with-the-original-implementation","title":"Issues with the Original Implementation","text":"<ol> <li> <p>Tight Coupling: The payment processing logic was tightly coupled with the <code>FlightOrder</code> class, making it difficult to add new payment methods without modifying the class.</p> </li> <li> <p>Code Duplication: Similar validation and processing logic was duplicated across different payment methods.</p> </li> <li> <p>Single Responsibility Principle Violation: The <code>FlightOrder</code> class was responsible for both order management and payment processing, violating the Single Responsibility Principle.</p> </li> <li> <p>Open/Closed Principle Violation: The class was not open for extension but closed for modification. Adding a new payment method required modifying the existing class.</p> </li> <li> <p>Maintainability Issues: Changes to payment processing logic required modifying the <code>FlightOrder</code> class, increasing the risk of introducing bugs.</p> </li> </ol>"},{"location":"design-smells/design-smell-1/#solution-strategy-pattern-implementation","title":"Solution: Strategy Pattern Implementation","text":"<p>The Strategy Pattern was implemented to address these issues by:</p> <ol> <li>Creating a common interface for all payment strategies</li> <li>Implementing concrete strategies for each payment method</li> <li>Modifying the <code>FlightOrder</code> class to use these strategies</li> </ol>"},{"location":"design-smells/design-smell-1/#1-payment-strategy-interface","title":"1. Payment Strategy Interface","text":"<p>A new <code>PaymentStrategy</code> interface was created to define the contract for all payment methods:</p> <pre><code>public interface PaymentStrategy {\n    /**\n     * Process a payment with the given amount.\n     * \n     * @param amount The amount to be paid\n     * @return true if payment was successful, false otherwise\n     * @throws IllegalStateException if payment information is invalid or payment fails\n     */\n    boolean pay(double amount) throws IllegalStateException;\n\n    /**\n     * Validates if the payment information is valid.\n     * \n     * @return true if the payment information is valid, false otherwise\n     */\n    boolean isValid();\n}\n</code></pre>"},{"location":"design-smells/design-smell-1/#2-concrete-strategy-implementations","title":"2. Concrete Strategy Implementations","text":""},{"location":"design-smells/design-smell-1/#credit-card-payment-strategy","title":"Credit Card Payment Strategy","text":"<pre><code>public class CreditCardPaymentStrategy implements PaymentStrategy {\n    private final CreditCard creditCard;\n\n    public CreditCardPaymentStrategy(String number, Date expirationDate, String cvv) {\n        this.creditCard = new CreditCard(number, expirationDate, cvv);\n    }\n\n    public CreditCardPaymentStrategy(CreditCard creditCard) {\n        this.creditCard = creditCard;\n    }\n\n    @Override\n    public boolean pay(double amount) throws IllegalStateException {\n        if (!isValid()) {\n            throw new IllegalStateException(\"Credit card information is not valid.\");\n        }\n\n        System.out.println(\"Paying \" + amount + \" using Credit Card.\");\n        double remainingAmount = creditCard.getAmount() - amount;\n        if (remainingAmount &lt; 0) {\n            System.out.printf(\"Card limit reached - Balance: %f%n\", remainingAmount);\n            throw new IllegalStateException(\"Card limit reached\");\n        }\n        creditCard.setAmount(remainingAmount);\n        return true;\n    }\n\n    @Override\n    public boolean isValid() {\n        return creditCard != null &amp;&amp; creditCard.isValid();\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-1/#paypal-payment-strategy","title":"PayPal Payment Strategy","text":"<pre><code>public class PaypalPaymentStrategy implements PaymentStrategy {\n    private final String email;\n    private final String password;\n\n    public PaypalPaymentStrategy(String email, String password) {\n        this.email = email;\n        this.password = password;\n    }\n\n    @Override\n    public boolean pay(double amount) throws IllegalStateException {\n        if (!isValid()) {\n            throw new IllegalStateException(\"PayPal credentials are not valid.\");\n        }\n\n        System.out.println(\"Paying \" + amount + \" using PayPal.\");\n        return true;\n    }\n\n    @Override\n    public boolean isValid() {\n        return email != null &amp;&amp; password != null &amp;&amp; \n               email.equals(Paypal.DATA_BASE.get(password));\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-1/#3-modified-flightorder-class","title":"3. Modified FlightOrder Class","text":"<p>The <code>FlightOrder</code> class was modified to use the Strategy Pattern:</p> <pre><code>public class FlightOrder extends Order {\n    private final List&lt;ScheduledFlight&gt; flights;\n    static List&lt;String&gt; noFlyList = Arrays.asList(\"Peter\", \"Johannes\");\n    private PaymentStrategy paymentStrategy;\n\n    // ... existing code ...\n\n    /**\n     * Sets the payment strategy to use for processing the order.\n     * \n     * @param paymentStrategy The payment strategy to use\n     */\n    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {\n        this.paymentStrategy = paymentStrategy;\n    }\n\n    /**\n     * Process the order with the current payment strategy.\n     * \n     * @return true if payment was successful, false otherwise\n     * @throws IllegalStateException if payment information is invalid or payment fails\n     */\n    public boolean processOrder() throws IllegalStateException {\n        if (isClosed()) {\n            // Payment is already proceeded\n            return true;\n        }\n\n        if (paymentStrategy == null) {\n            throw new IllegalStateException(\"Payment strategy is not set.\");\n        }\n\n        if (!paymentStrategy.isValid()) {\n            throw new IllegalStateException(\"Payment information is not valid.\");\n        }\n\n        boolean isPaid = paymentStrategy.pay(this.getPrice());\n        if (isPaid) {\n            this.setClosed();\n        }\n        return isPaid;\n    }\n\n    // Convenience methods for backward compatibility\n    public boolean processOrderWithCreditCardDetail(String number, Date expirationDate, String cvv) throws IllegalStateException {\n        setPaymentStrategy(new CreditCardPaymentStrategy(number, expirationDate, cvv));\n        return processOrder();\n    }\n\n    public boolean processOrderWithCreditCard(CreditCard creditCard) throws IllegalStateException {\n        setPaymentStrategy(new CreditCardPaymentStrategy(creditCard));\n        return processOrder();\n    }\n\n    public boolean processOrderWithPayPal(String email, String password) throws IllegalStateException {\n        setPaymentStrategy(new PaypalPaymentStrategy(email, password));\n        return processOrder();\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-1/#benefits-of-the-refactoring","title":"Benefits of the Refactoring","text":"<ol> <li> <p>Decoupled Payment Logic: Payment processing logic is now decoupled from the <code>FlightOrder</code> class, making it easier to maintain and extend.</p> </li> <li> <p>Improved Code Organization: Each payment method has its own class, following the Single Responsibility Principle.</p> </li> <li> <p>Extensibility: New payment methods can be added by implementing the <code>PaymentStrategy</code> interface without modifying existing code, adhering to the Open/Closed Principle.</p> </li> <li> <p>Reduced Duplication: Common payment processing logic is now centralized in the <code>processOrder()</code> method.</p> </li> <li> <p>Runtime Flexibility: Payment methods can be changed at runtime by setting a different payment strategy.</p> </li> <li> <p>Testability: Payment strategies can be tested in isolation, making unit testing easier.</p> </li> </ol>"},{"location":"design-smells/design-smell-1/#example-usage","title":"Example Usage","text":"<p>Before refactoring: <pre><code>FlightOrder order = customer.createOrder(passengerNames, flights, totalPrice);\norder.processOrderWithCreditCard(creditCard);\n// or\norder.processOrderWithPayPal(email, password);\n</code></pre></p> <p>After refactoring: <pre><code>FlightOrder order = customer.createOrder(passengerNames, flights, totalPrice);\n// Option 1: Using convenience methods (backward compatible)\norder.processOrderWithCreditCard(creditCard);\n// or\norder.processOrderWithPayPal(email, password);\n\n// Option 2: Using the strategy pattern directly\norder.setPaymentStrategy(new CreditCardPaymentStrategy(creditCard));\norder.processOrder();\n// or\norder.setPaymentStrategy(new PaypalPaymentStrategy(email, password));\norder.processOrder();\n</code></pre></p>"},{"location":"design-smells/design-smell-1/#trade-offs","title":"Trade-offs","text":""},{"location":"design-smells/design-smell-1/#advantages-lets-go-solid","title":"Advantages (Lets go SOLID!!)","text":"<ol> <li> <p>Flexibility: The Strategy Pattern provides runtime flexibility to switch between different payment methods.</p> </li> <li> <p>Maintainability: Code is more maintainable with clear separation of concerns.</p> </li> <li> <p>Extensibility: New payment methods can be added without modifying existing code.</p> </li> </ol>"},{"location":"design-smells/design-smell-1/#disadvantages","title":"Disadvantages","text":"<ol> <li> <p>Increased Number of Classes: The refactoring introduces additional classes, which might increase the complexity of the codebase for small projects.</p> </li> <li> <p>Potential Overhead: For very simple use cases, the pattern might introduce unnecessary abstraction. (but had to do cause of srp and class activity constraints lol)</p> </li> </ol>"},{"location":"design-smells/design-smell-2/","title":"Factory Method Pattern Refactoring","text":"<p>This md details the implementation of the Factory Method Pattern in this repository to improve the aircraft class hierarchy and management.</p>"},{"location":"design-smells/design-smell-2/#problem-identification","title":"Problem Identification","text":""},{"location":"design-smells/design-smell-2/#original-implementation","title":"Original Implementation","text":"<p>In the original codebase, the aircraft types (<code>PassengerPlane</code>, <code>Helicopter</code>, and <code>PassengerDrone</code>) had inconsistent interfaces and were handled using type checking and casting in the <code>Flight</code> and <code>ScheduledFlight</code> classes:</p> <pre><code>// In Flight.java\nprivate boolean isAircraftValid(Airport airport) {\n    return Arrays.stream(airport.getAllowedAircrafts()).anyMatch(x -&gt; {\n        String model;\n        if (this.aircraft instanceof PassengerPlane) {\n            model = ((PassengerPlane) this.aircraft).model;\n        } else if (this.aircraft instanceof Helicopter) {\n            model = ((Helicopter) this.aircraft).getModel();\n        } else if (this.aircraft instanceof PassengerDrone) {\n            model = \"HypaHype\";\n        } else {\n            throw new IllegalArgumentException(String.format(\"Aircraft is not recognized\"));\n        }\n        return x.equals(model);\n    });\n}\n\n// In ScheduledFlight.java\npublic int getCrewMemberCapacity() throws NoSuchFieldException {\n    if (this.aircraft instanceof PassengerPlane) {\n        return ((PassengerPlane) this.aircraft).crewCapacity;\n    }\n    if (this.aircraft instanceof Helicopter) {\n        return 2;\n    }\n    if (this.aircraft instanceof PassengerDrone) {\n        return 0;\n    }\n    throw new NoSuchFieldException(\"this aircraft has no information about its crew capacity\");\n}\n\npublic int getCapacity() throws NoSuchFieldException {\n    if (this.aircraft instanceof PassengerPlane) {\n        return ((PassengerPlane) this.aircraft).passengerCapacity;\n    }\n    if (this.aircraft instanceof Helicopter) {\n        return ((Helicopter) this.aircraft).getPassengerCapacity();\n    }\n    if (this.aircraft instanceof PassengerDrone) {\n        return 4;\n    }\n    throw new NoSuchFieldException(\"this aircraft has no information about its capacity\");\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#issues-with-the-original-implementation","title":"Issues with the Original Implementation","text":"<ol> <li> <p>Type Checking: The code relied on <code>instanceof</code> checks, which is a sign of poor design and violates the Open/Closed Principle.</p> </li> <li> <p>Inconsistent Interfaces: The aircraft classes had inconsistent methods and properties. For example, <code>PassengerPlane</code> used public fields while <code>Helicopter</code> used private fields with getters.</p> </li> <li> <p>Tight Coupling: The <code>Flight</code> and <code>ScheduledFlight</code> classes were tightly coupled to the concrete aircraft implementations.</p> </li> <li> <p>Code Duplication: Similar type-checking logic was duplicated across multiple methods.</p> </li> <li> <p>Hard-coded Values: Some values like the crew capacity for helicopters and passenger capacity for drones were hard-coded in multiple places.</p> </li> <li> <p>Maintainability Issues: Adding a new aircraft type would require modifying the existing code in multiple places.</p> </li> </ol>"},{"location":"design-smells/design-smell-2/#solution-factory-method-pattern-implementation","title":"Solution: Factory Method Pattern Implementation","text":"<p>The Factory Method Pattern was implemented to address these issues by:</p> <ol> <li>Creating a common interface for all aircraft types</li> <li>Refactoring existing aircraft classes to implement this interface</li> <li>Creating a factory class to handle aircraft creation</li> <li>Updating client code to use the interface instead of concrete types</li> </ol>"},{"location":"design-smells/design-smell-2/#1-aircraft-interface","title":"1. Aircraft Interface","text":"<p>A new <code>Aircraft</code> interface was created to define the contract for all aircraft types:</p> <pre><code>public interface Aircraft {\n    String getModel();\n    int getPassengerCapacity() throws NoSuchFieldException;\n    int getCrewCapacity() throws NoSuchFieldException;\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#2-refactored-aircraft-classes","title":"2. Refactored Aircraft Classes","text":""},{"location":"design-smells/design-smell-2/#passengerplane","title":"PassengerPlane","text":"<pre><code>public class PassengerPlane implements Aircraft {\n    public String model;\n    public int passengerCapacity;\n    public int crewCapacity;\n\n    public PassengerPlane(String model) {\n        this.model = model;\n        switch (model) {\n            case \"A380\":\n                passengerCapacity = 500;\n                crewCapacity = 42;\n                break;\n            case \"A350\":\n                passengerCapacity = 320;\n                crewCapacity = 40;\n                break;\n            case \"Embraer 190\":\n                passengerCapacity = 25;\n                crewCapacity = 5;\n                break;\n            case \"Antonov AN2\":\n                passengerCapacity = 15;\n                crewCapacity = 3;\n                break;\n            default:\n                throw new IllegalArgumentException(String.format(\"Model type '%s' is not recognized\", model));\n        }\n    }\n\n    @Override\n    public String getModel() {\n        return model;\n    }\n\n    @Override\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    @Override\n    public int getCrewCapacity() {\n        return crewCapacity;\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#helicopter","title":"Helicopter","text":"<pre><code>public class Helicopter implements Aircraft {\n    private final String model;\n    private final int passengerCapacity;\n\n    public Helicopter(String model) {\n        if (model.equals(\"H1\")) {\n            passengerCapacity = 4;\n        } else if (model.equals(\"H2\")) {\n            passengerCapacity = 6;\n        } else {\n            throw new IllegalArgumentException(String.format(\"Model type '%s' is not recognized\", model));\n        }\n        this.model = model;\n    }\n\n    @Override\n    public String getModel() {\n        return model;\n    }\n\n    @Override\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    @Override\n    public int getCrewCapacity() {\n        return 2; // Fixed for all helicopters\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#passengerdrone","title":"PassengerDrone","text":"<pre><code>public class PassengerDrone implements Aircraft {\n    private final String model;\n\n    public PassengerDrone(String model) {\n        if (model.equals(\"HypaHype\")) {\n            this.model = model;\n        } else {\n            throw new IllegalArgumentException(String.format(\"Model type '%s' is not recognized\", model));\n        }\n    }\n\n    @Override\n    public String getModel() {\n        return model;\n    }\n\n    @Override\n    public int getPassengerCapacity() {\n        return 4; // Fixed for all drones\n    }\n\n    @Override\n    public int getCrewCapacity() {\n        return 0; // No crew needed\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#3-aircraft-factory","title":"3. Aircraft Factory","text":"<p>A new <code>AircraftFactory</code> class was created to encapsulate aircraft creation logic:</p> <pre><code>public class AircraftFactory {\n\n    public static Aircraft createAircraft(String type, String model) {\n        switch (type.toLowerCase()) {\n            case \"plane\":\n                return new PassengerPlane(model);\n            case \"helicopter\":\n                return new Helicopter(model);\n            case \"drone\":\n                return new PassengerDrone(model);\n            default:\n                throw new IllegalArgumentException(\"Unknown aircraft type: \" + type);\n        }\n    }\n\n    // Convenience methods\n    public static Aircraft createPlane(String model) {\n        return new PassengerPlane(model);\n    }\n\n    public static Aircraft createHelicopter(String model) {\n        return new Helicopter(model);\n    }\n\n    public static Aircraft createDrone(String model) {\n        return new PassengerDrone(model);\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#4-updated-client-code","title":"4. Updated Client Code","text":""},{"location":"design-smells/design-smell-2/#flight-class","title":"Flight Class","text":"<pre><code>public class Flight {\n    private int number;\n    private Airport departure;\n    private Airport arrival;\n    protected Aircraft aircraft;\n\n    public Flight(int number, Airport departure, Airport arrival, Aircraft aircraft) throws IllegalArgumentException {\n        this.number = number;\n        this.departure = departure;\n        this.arrival = arrival;\n        this.aircraft = aircraft;\n        checkValidity();\n    }\n\n    private void checkValidity() throws IllegalArgumentException {\n        if (!isAircraftValid(departure) || !isAircraftValid(arrival)) {\n            throw new IllegalArgumentException(\"Selected aircraft is not valid for the selected route.\");\n        }\n    }\n\n    private boolean isAircraftValid(Airport airport) {\n        return Arrays.stream(airport.getAllowedAircrafts())\n                .anyMatch(x -&gt; x.equals(aircraft.getModel()));\n    }\n\n    // Rest of the class remains the same\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#scheduledflight-class","title":"ScheduledFlight Class","text":"<pre><code>public class ScheduledFlight extends Flight {\n    // Existing code...\n\n    public int getCrewMemberCapacity() throws NoSuchFieldException {\n        return aircraft.getCrewCapacity();\n    }\n\n    public int getCapacity() throws NoSuchFieldException {\n        return aircraft.getPassengerCapacity();\n    }\n\n    // Rest of the class remains the same\n}\n</code></pre>"},{"location":"design-smells/design-smell-2/#benefits-of-the-refactoring","title":"Benefits of the Refactoring","text":"<ol> <li> <p>Eliminated Type Checking: No more <code>instanceof</code> checks, making the code cleaner and more maintainable.</p> </li> <li> <p>Consistent Interface: All aircraft types now implement the same interface, providing a consistent way to interact with them.</p> </li> <li> <p>Decoupled Client Code: <code>Flight</code> and <code>ScheduledFlight</code> classes now depend on the abstract <code>Aircraft</code> interface rather than concrete implementations.</p> </li> <li> <p>Improved Encapsulation: Aircraft creation logic is now encapsulated in the <code>AircraftFactory</code> class.</p> </li> <li> <p>Better Extensibility: New aircraft types can be added by implementing the <code>Aircraft</code> interface without modifying existing client code.</p> </li> <li> <p>Reduced Code Duplication: Common logic for type checking has been eliminated.</p> </li> <li> <p>Centralized Aircraft Configuration: Aircraft configuration is now managed within each aircraft class.</p> </li> </ol>"},{"location":"design-smells/design-smell-2/#example-usage","title":"Example Usage","text":"<p>Before refactoring: <pre><code>// Creating aircraft\nPassengerPlane plane = new PassengerPlane(\"A380\");\nHelicopter helicopter = new Helicopter(\"H1\");\nPassengerDrone drone = new PassengerDrone(\"HypaHype\");\n\n// Using aircraft in Flight\nFlight flight1 = new Flight(1, departure, arrival, plane);\nFlight flight2 = new Flight(2, departure, arrival, helicopter);\nFlight flight3 = new Flight(3, departure, arrival, drone);\n</code></pre></p> <p>After refactoring: <pre><code>// Using the factory to create aircraft\nAircraft plane = AircraftFactory.createPlane(\"A380\");\nAircraft helicopter = AircraftFactory.createHelicopter(\"H1\");\nAircraft drone = AircraftFactory.createDrone(\"HypaHype\");\n\n// Alternative using the general factory method\nAircraft plane2 = AircraftFactory.createAircraft(\"plane\", \"A380\");\n\n// Using aircraft in Flight - interface remains the same\nFlight flight1 = new Flight(1, departure, arrival, plane);\nFlight flight2 = new Flight(2, departure, arrival, helicopter);\nFlight flight3 = new Flight(3, departure, arrival, drone);\n</code></pre></p>"},{"location":"design-smells/design-smell-2/#trade-offs","title":"Trade-offs","text":""},{"location":"design-smells/design-smell-2/#advantages","title":"Advantages","text":"<ol> <li> <p>Better Design: The Factory Method Pattern promotes the use of interfaces over implementations, following the Dependency Inversion Principle.</p> </li> <li> <p>Extensibility: New aircraft types can be added without modifying existing code, adhering to the Open/Closed Principle.</p> </li> <li> <p>Maintainability: Code is more maintainable with clear separation of concerns and consistent interfaces.</p> </li> <li> <p>Type Safety: The use of a common interface prevents type errors and removes the need for type casting.</p> </li> </ol>"},{"location":"design-smells/design-smell-2/#disadvantages","title":"Disadvantages","text":"<ol> <li> <p>Additional Classes: The pattern introduces additional interfaces and classes, which might increase the complexity of the codebase for small projects.</p> </li> <li> <p>Indirection: The factory adds a level of indirection, which might make the code slightly harder to follow for new developers.</p> </li> <li> <p>Performance: There might be a very slight performance overhead due to the additional abstraction layer, but it's negligible in most cases.</p> </li> </ol>"},{"location":"design-smells/design-smell-3/","title":"Template Method Pattern Refactoring","text":"<p>This document details the implementation of the Template Method Pattern in the flight reservation system to standardize and improve the order processing workflow.</p>"},{"location":"design-smells/design-smell-3/#problem-identification","title":"Problem Identification","text":""},{"location":"design-smells/design-smell-3/#original-implementation","title":"Original Implementation","text":"<p>In the original codebase, the order processing logic was scattered across the <code>FlightOrder</code> class with inconsistent validation and processing steps:</p> <pre><code>// In FlightOrder.java\npublic boolean processOrder() throws IllegalStateException {\n    if (isClosed()) {\n        // Payment is already proceeded\n        return true;\n    }\n\n    if (paymentStrategy == null) {\n        throw new IllegalStateException(\"Payment strategy is not set.\");\n    }\n\n    if (!paymentStrategy.isValid()) {\n        throw new IllegalStateException(\"Payment information is not valid.\");\n    }\n\n    boolean isPaid = paymentStrategy.pay(this.getPrice());\n    if (isPaid) {\n        this.setClosed();\n    }\n    return isPaid;\n}\n\n// Various convenience methods handled their own validation\npublic boolean processOrderWithCreditCard(CreditCard creditCard) throws IllegalStateException {\n    setPaymentStrategy(new CreditCardPaymentStrategy(creditCard));\n    return processOrder();\n}\n</code></pre>"},{"location":"design-smells/design-smell-3/#issues-with-the-original-implementation","title":"Issues with the Original Implementation","text":"<ol> <li> <p>Lack of Standardization: The order processing sequence wasn't standardized, making it difficult to ensure all orders follow the same workflow.</p> </li> <li> <p>Code Duplication: Similar validation and processing logic was duplicated across different methods.</p> </li> <li> <p>Poor Extensibility: Adding new order types would require replicating the entire order processing logic.</p> </li> <li> <p>Inconsistent Error Handling: Different methods had different approaches to error handling.</p> </li> <li> <p>Tight Coupling: The order processing steps were tightly coupled, making it difficult to modify individual steps without affecting others.</p> </li> </ol>"},{"location":"design-smells/design-smell-3/#solution-template-method-pattern-implementation","title":"Solution: Template Method Pattern Implementation","text":"<p>The Template Method Pattern was implemented to address these issues by:</p> <ol> <li>Defining a skeleton algorithm in a template method in the base class</li> <li>Deferring some steps to subclasses</li> <li>Ensuring common steps are implemented once in the parent class</li> </ol>"},{"location":"design-smells/design-smell-3/#1-modified-base-order-class","title":"1. Modified Base Order Class","text":"<p>The <code>Order</code> abstract class was updated to include the template method for order processing:</p> <pre><code>public abstract class Order {\n    private final UUID id;\n    private double price;\n    private boolean isClosed = false;\n    private Customer customer;\n    private List&lt;Passenger&gt; passengers;\n\n    public Order() {\n        this.id = UUID.randomUUID();\n    }\n\n    // Template method defining the skeleton of order processing\n    public final boolean processOrder() throws IllegalStateException {\n        if (isClosed()) {\n            return true;\n        }\n\n        if (!validateOrder()) {\n            throw new IllegalStateException(\"Order validation failed.\");\n        }\n\n        if (!processPayment()) {\n            return false;\n        }\n\n        finalizeOrder();\n        return true;\n    }\n\n    // Abstract methods to be implemented by subclasses\n    protected abstract boolean validateOrder();\n    protected abstract boolean processPayment();\n\n    // Hook method with default implementation\n    protected void finalizeOrder() {\n        setClosed();\n    }\n\n    // Getters and setters remain the same\n    public UUID getId() {\n        return id;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    public Customer getCustomer() {\n        return customer;\n    }\n\n    public void setCustomer(Customer customer) {\n        this.customer = customer;\n    }\n\n    public List&lt;Passenger&gt; getPassengers() {\n        return passengers;\n    }\n\n    public void setPassengers(List&lt;Passenger&gt; passengers) {\n        this.passengers = passengers;\n    }\n\n    public boolean isClosed() {\n        return isClosed;\n    }\n\n    public void setClosed() {\n        isClosed = true;\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-3/#2-updated-flightorder-implementation","title":"2. Updated FlightOrder Implementation","text":"<p>The <code>FlightOrder</code> class was updated to implement the abstract methods defined in the base class:</p> <pre><code>public class FlightOrder extends Order {\n    private final List&lt;ScheduledFlight&gt; flights;\n    static List&lt;String&gt; noFlyList = Arrays.asList(\"Peter\", \"Johannes\");\n    private PaymentStrategy paymentStrategy;\n\n    public FlightOrder(List&lt;ScheduledFlight&gt; flights) {\n        this.flights = flights;\n    }\n\n    @Override\n    protected boolean validateOrder() {\n        if (paymentStrategy == null) {\n            return false;\n        }\n\n        if (getCustomer() == null) {\n            return false;\n        }\n\n        if (noFlyList.contains(getCustomer().getName())) {\n            return false;\n        }\n\n        if (getPassengers() == null || getPassengers().isEmpty()) {\n            return false;\n        }\n\n        for (var passenger : getPassengers()) {\n            if (noFlyList.contains(passenger.getName())) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    protected boolean processPayment() {\n        if (!paymentStrategy.isValid()) {\n            return false;\n        }\n\n        return paymentStrategy.pay(this.getPrice());\n    }\n\n    // The rest of the class remains the same\n    public static List&lt;String&gt; getNoFlyList() {\n        return noFlyList;\n    }\n\n    public List&lt;ScheduledFlight&gt; getScheduledFlights() {\n        return flights;\n    }\n\n    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {\n        this.paymentStrategy = paymentStrategy;\n    }\n\n    // Convenience methods\n    public boolean processOrderWithCreditCardDetail(String number, Date expirationDate, String cvv) throws IllegalStateException {\n        setPaymentStrategy(new CreditCardPaymentStrategy(number, expirationDate, cvv));\n        return processOrder();\n    }\n\n    public boolean processOrderWithCreditCard(CreditCard creditCard) throws IllegalStateException {\n        setPaymentStrategy(new CreditCardPaymentStrategy(creditCard));\n        return processOrder();\n    }\n\n    public boolean processOrderWithPayPal(String email, String password) throws IllegalStateException {\n        setPaymentStrategy(new PaypalPaymentStrategy(email, password));\n        return processOrder();\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-3/#benefits-of-the-refactoring","title":"Benefits of the Refactoring","text":"<ol> <li> <p>Standardized Process: All orders now follow the same processing sequence, ensuring consistency.</p> </li> <li> <p>Code Reuse: Common steps are implemented once in the parent class, reducing duplication.</p> </li> <li> <p>Improved Extensibility: New order types can be added by extending the base <code>Order</code> class and implementing only the required abstract methods.</p> </li> <li> <p>Clearer Responsibilities: Each step in the order processing sequence has a clear responsibility.</p> </li> <li> <p>Consistent Error Handling: Error handling is standardized across all order types.</p> </li> <li> <p>Better Control Over Process: The template method controls the overall flow, ensuring steps are executed in the correct order.</p> </li> </ol>"},{"location":"design-smells/design-smell-3/#example-usage","title":"Example Usage","text":"<p>The usage of the orders remains the same from the client's perspective, but internally the process is now more structured:</p> <pre><code>// Create a flight order\nFlightOrder order = customer.createOrder(passengerNames, flights, totalPrice);\n\n// Set payment strategy and process\norder.setPaymentStrategy(new CreditCardPaymentStrategy(creditCard));\nboolean success = order.processOrder();\n\n// Or use convenience methods\nboolean success = order.processOrderWithCreditCard(creditCard);\n</code></pre>"},{"location":"design-smells/design-smell-3/#trade-offs","title":"Trade-offs","text":""},{"location":"design-smells/design-smell-3/#advantages","title":"Advantages","text":"<ol> <li> <p>Better Design: The Template Method Pattern clearly separates invariant parts of the algorithm from variant parts.</p> </li> <li> <p>Reusability: Common steps are implemented once, reducing duplication.</p> </li> <li> <p>Extensibility: The pattern makes it easier to add new types of orders without changing the processing sequence.</p> </li> <li> <p>Control: The template method controls the overall sequence, preventing subclasses from changing essential steps.</p> </li> </ol>"},{"location":"design-smells/design-smell-3/#disadvantages","title":"Disadvantages","text":"<ol> <li> <p>Limited Flexibility: Subclasses can only override the steps provided by the template method, which might be restrictive in some cases.</p> </li> <li> <p>Complexity: The pattern adds a level of abstraction, which might make the code slightly harder to follow for new developers.</p> </li> <li> <p>Inheritance Limitations: The pattern relies on inheritance rather than composition, which can sometimes be a limitation.</p> </li> </ol>"},{"location":"design-smells/design-smell-4/","title":"Observer Pattern Refactoring","text":"<p>This document details the implementation of the Observer Pattern in the flight reservation system to provide notifications for flight schedule changes.</p>"},{"location":"design-smells/design-smell-4/#problem-identification","title":"Problem Identification","text":""},{"location":"design-smells/design-smell-4/#original-implementation","title":"Original Implementation","text":"<p>In the original codebase, there was no mechanism for notifying customers about changes to flights they had booked:</p> <ul> <li>When flight schedules changed, there was no way to automatically update customers</li> <li>Any price changes, cancellations, or other important flight updates weren't communicated</li> <li>The system lacked a standardized way to handle flight-related notifications</li> <li>Customers had to manually check for updates to their booked flights</li> </ul> <pre><code>// In ScheduledFlight.java - original implementation had no notification mechanism\npublic void setCurrentPrice(double currentPrice) {\n    this.currentPrice = currentPrice;\n    // No way to notify affected customers\n}\n\n// In Customer.java - no way to receive updates about flight changes\npublic FlightOrder createOrder(List&lt;String&gt; passengerNames, List&lt;ScheduledFlight&gt; flights, double price) {\n    // Creates order but doesn't establish ongoing communication about flight changes\n}\n</code></pre>"},{"location":"design-smells/design-smell-4/#issues-with-the-original-implementation","title":"Issues with the Original Implementation","text":"<ol> <li> <p>Missing Communication Channel: No mechanism existed for flights to communicate changes to interested parties.</p> </li> <li> <p>Manual Update Process: Customers needed to manually check for flight updates.</p> </li> <li> <p>Tight Coupling Potential: Any future notification system would likely couple flights and customers tightly.</p> </li> <li> <p>Limited Extensibility: Adding notification features would require significant changes across multiple classes.</p> </li> <li> <p>Inconsistent Updates: Without a standardized notification system, updates might be handled inconsistently.</p> </li> </ol>"},{"location":"design-smells/design-smell-4/#solution-observer-pattern-implementation","title":"Solution: Observer Pattern Implementation","text":"<p>The Observer Pattern was implemented to address these issues by:</p> <ol> <li>Creating interfaces for both the subject (flights) and observers (customers)</li> <li>Modifying the <code>ScheduledFlight</code> class to track and notify observers</li> <li>Making the <code>Customer</code> class respond to flight updates</li> <li>Setting up the communication channel when orders are created</li> </ol>"},{"location":"design-smells/design-smell-4/#1-observer-interface","title":"1. Observer Interface","text":"<p>A new <code>FlightObserver</code> interface defines how observers receive updates:</p> <pre><code>package flight.reservation.observer;\n\nimport flight.reservation.flight.ScheduledFlight;\n\npublic interface FlightObserver {\n    void update(ScheduledFlight flight, String message);\n}\n</code></pre>"},{"location":"design-smells/design-smell-4/#2-subject-interface","title":"2. Subject Interface","text":"<p>The <code>FlightSubject</code> interface defines how subjects manage and notify observers:</p> <pre><code>package flight.reservation.observer;\n\npublic interface FlightSubject {\n    void registerObserver(FlightObserver observer);\n    void removeObserver(FlightObserver observer);\n    void notifyObservers(String message);\n}\n</code></pre>"},{"location":"design-smells/design-smell-4/#3-modified-scheduledflight-class","title":"3. Modified ScheduledFlight Class","text":"<p>The <code>ScheduledFlight</code> class was updated to implement <code>FlightSubject</code>:</p> <pre><code>public class ScheduledFlight extends Flight implements FlightSubject {\n    private final List&lt;Passenger&gt; passengers;\n    private final Date departureTime;\n    private double currentPrice = 100;\n    private final List&lt;FlightObserver&gt; observers = new ArrayList&lt;&gt;();\n\n    // Constructor remains the same\n\n    @Override\n    public void registerObserver(FlightObserver observer) {\n        if (!observers.contains(observer)) {\n            observers.add(observer);\n        }\n    }\n\n    @Override\n    public void removeObserver(FlightObserver observer) {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers(String message) {\n        for (FlightObserver observer : observers) {\n            observer.update(this, message);\n        }\n    }\n\n    public void setCurrentPrice(double currentPrice) {\n        double oldPrice = this.currentPrice;\n        this.currentPrice = currentPrice;\n        notifyObservers(\"Flight \" + getNumber() + \" price changed from \" + \n                        oldPrice + \" to \" + currentPrice);\n    }\n\n    public void setDepartureTime(Date newDepartureTime) {\n        Date oldDepartureTime = this.departureTime;\n        // Since departureTime is final, we would need to create a new ScheduledFlight\n        // For this example, let's just pretend we updated it\n        notifyObservers(\"Flight \" + getNumber() + \" departure time changed from \" + \n                        oldDepartureTime + \" to \" + newDepartureTime);\n    }\n\n    public void addPassengers(List&lt;Passenger&gt; newPassengers) {\n        this.passengers.addAll(newPassengers);\n        notifyObservers(\"New passengers added to flight \" + getNumber());\n    }\n\n    public void removePassengers(List&lt;Passenger&gt; removedPassengers) {\n        this.passengers.removeAll(removedPassengers);\n        notifyObservers(\"Passengers removed from flight \" + getNumber());\n    }\n\n    public void cancelFlight() {\n        notifyObservers(\"Flight \" + getNumber() + \" has been cancelled\");\n    }\n\n    // Rest of the original methods remain the same\n}\n</code></pre>"},{"location":"design-smells/design-smell-4/#4-updated-customer-class","title":"4. Updated Customer Class","text":"<p>The <code>Customer</code> class was modified to implement <code>FlightObserver</code>:</p> <pre><code>public class Customer implements FlightObserver {\n    private String email;\n    private String name;\n    private List&lt;Order&gt; orders;\n    private List&lt;String&gt; notifications = new ArrayList&lt;&gt;();\n\n    // Constructor remains the same\n\n    @Override\n    public void update(ScheduledFlight flight, String message) {\n        String notification = \"Notification for flight \" + flight.getNumber() + \n                              \" from \" + flight.getDeparture().getCode() + \n                              \" to \" + flight.getArrival().getCode() + \": \" + message;\n\n        notifications.add(notification);\n        System.out.println(\"Customer \" + name + \" received: \" + notification);\n    }\n\n    public FlightOrder createOrder(List&lt;String&gt; passengerNames, List&lt;ScheduledFlight&gt; flights, double price) {\n        if (!isOrderValid(passengerNames, flights)) {\n            throw new IllegalStateException(\"Order is not valid\");\n        }\n        FlightOrder order = new FlightOrder(flights);\n        order.setCustomer(this);\n        order.setPrice(price);\n        List&lt;Passenger&gt; passengers = passengerNames\n                .stream()\n                .map(Passenger::new)\n                .collect(Collectors.toList());\n        order.setPassengers(passengers);\n        order.getScheduledFlights().forEach(scheduledFlight -&gt; {\n            scheduledFlight.addPassengers(passengers);\n            scheduledFlight.registerObserver(this); // Register as observer for flight updates\n        });\n        orders.add(order);\n        return order;\n    }\n\n    public List&lt;String&gt; getNotifications() {\n        return notifications;\n    }\n\n    // Rest of the original methods remain the same\n}\n</code></pre>"},{"location":"design-smells/design-smell-4/#benefits-of-the-refactoring","title":"Benefits of the Refactoring","text":"<ol> <li> <p>Automatic Notifications: Customers are automatically notified of any changes to their booked flights.</p> </li> <li> <p>Loose Coupling: The Observer Pattern creates a loose coupling between flights and customers. Flights don't need to know the specifics of who is observing them, just that observers exist.</p> </li> <li> <p>Improved Customer Experience: Customers now receive timely updates about flight changes, cancellations, and other important information.</p> </li> <li> <p>Extensibility: The notification system can be easily extended to include other types of observers (e.g., airline staff, airport systems) without modifying the <code>ScheduledFlight</code> class.</p> </li> <li> <p>Consistent Updates: All observers receive the same notification messages, ensuring consistency in communication.</p> </li> <li> <p>Maintainability: The notification logic is centralized, making it easier to maintain and update.</p> </li> </ol>"},{"location":"design-smells/design-smell-4/#example-usage","title":"Example Usage","text":"<p>Here's an example of how the Observer Pattern works in practice:</p> <pre><code>// Create airports, aircraft, and a scheduled flight\nAirport departureAirport = new Airport(\"Berlin Airport\", \"BER\", \"Berlin, Berlin\");\nAirport arrivalAirport = new Airport(\"Frankfurt Airport\", \"FRA\", \"Frankfurt, Hesse\");\nAircraft aircraft = AircraftFactory.createPlane(\"A380\");\nScheduledFlight flight = new ScheduledFlight(101, departureAirport, arrivalAirport, aircraft, departureTime, 299.99);\n\n// Create customers and book flights\nCustomer john = new Customer(\"John\", \"john@example.com\");\nCustomer alice = new Customer(\"Alice\", \"alice@example.com\");\njohn.createOrder(Arrays.asList(\"John\", \"Jane\"), Arrays.asList(flight), 599.98);\nalice.createOrder(Arrays.asList(\"Alice\"), Arrays.asList(flight), 299.99);\n\n// When changes occur, customers are automatically notified\nflight.setCurrentPrice(349.99);\nflight.setDepartureTime(newDepartureTime);\nflight.cancelFlight();\n\n// Notifications can be accessed\nList&lt;String&gt; johnsNotifications = john.getNotifications();\nList&lt;String&gt; alicesNotifications = alice.getNotifications();\n</code></pre>"},{"location":"design-smells/design-smell-4/#trade-offs","title":"Trade-offs","text":""},{"location":"design-smells/design-smell-4/#advantages","title":"Advantages","text":"<ol> <li> <p>Real-time Updates: The Observer Pattern provides a mechanism for real-time updates, improving customer service.</p> </li> <li> <p>Decoupled Design: Subjects and observers are decoupled, allowing for changes to either without affecting the other.</p> </li> <li> <p>Dynamic Relationships: Observers can register and unregister at runtime, allowing for dynamic relationship management.</p> </li> <li> <p>Open/Closed Principle: The system follows the Open/Closed Principle, allowing for new observers without modifying existing code.</p> </li> </ol>"},{"location":"design-smells/design-smell-4/#disadvantages","title":"Disadvantages","text":"<ol> <li> <p>Memory Management: If observers forget to unregister, it could lead to memory leaks (though Java's garbage collection helps mitigate this).</p> </li> <li> <p>Unexpected Updates: Observers might receive updates they don't need or expect, especially if the notification system is not carefully designed.</p> </li> <li> <p>Order of Notification: The order in which observers are notified is not guaranteed, which could be an issue for some applications.</p> </li> <li> <p>Performance Overhead: For a large number of observers, there could be a performance impact when notifying all of them.</p> </li> </ol>"},{"location":"design-smells/design-smell-5/","title":"Composite Pattern Implementation","text":"<p>This document details the implementation of the Composite Pattern in the flight reservation system to handle both simple direct flights and complex multi-leg journeys.</p>"},{"location":"design-smells/design-smell-5/#problem-identification","title":"Problem Identification","text":""},{"location":"design-smells/design-smell-5/#original-implementation","title":"Original Implementation","text":"<p>In the original codebase, the system was only designed to handle individual flights:</p> <pre><code>// Booking a single flight\nFlightOrder order = customer.createOrder(passengerNames, Arrays.asList(flight), price);\n</code></pre> <p>There was no structured way to handle more complex travel itineraries consisting of multiple connecting flights. Each flight had to be booked separately, and there was no concept of a unified journey.</p>"},{"location":"design-smells/design-smell-5/#issues-with-the-original-implementation","title":"Issues with the Original Implementation","text":"<ol> <li> <p>Limited Support for Complex Itineraries: The system could not represent multi-leg journeys as a cohesive unit.</p> </li> <li> <p>Inconsistent Handling: Direct flights and connecting flights would need different handling logic in client code.</p> </li> <li> <p>Difficulty in Calculating Journey Properties: Properties like total price, travel time, and distance for complex itineraries would need to be calculated manually.</p> </li> <li> <p>Passenger Management Complexity: Adding or removing passengers from a multi-leg journey would require operations on each individual flight.</p> </li> <li> <p>No Unified Interface: There was no common interface to work with both simple and complex travel arrangements.</p> </li> </ol>"},{"location":"design-smells/design-smell-5/#solution-composite-pattern-implementation","title":"Solution: Composite Pattern Implementation","text":"<p>The Composite Pattern was implemented to address these issues by:</p> <ol> <li>Creating a common <code>Journey</code> interface for both simple flights and complex itineraries</li> <li>Implementing a <code>SingleFlightJourney</code> for direct flights</li> <li>Implementing a <code>MultiFlightJourney</code> that can contain multiple journeys</li> <li>Adding a factory to create different types of journeys</li> </ol>"},{"location":"design-smells/design-smell-5/#1-journey-interface","title":"1. Journey Interface","text":"<p>A common <code>Journey</code> interface defines operations for all journey types:</p> <pre><code>package flight.reservation.journey;\n\nimport flight.reservation.Airport;\nimport flight.reservation.Passenger;\nimport flight.reservation.flight.ScheduledFlight;\n\nimport java.util.Date;\nimport java.util.List;\n\npublic interface Journey {\n    double getPrice();\n    Airport getDeparture();\n    Airport getArrival();\n    Date getDepartureTime();\n    Date getArrivalTime();\n    List&lt;Airport&gt; getStops();\n    List&lt;ScheduledFlight&gt; getFlights();\n    int getTotalDistance();\n    void addPassenger(Passenger passenger);\n    void removePassenger(Passenger passenger);\n    List&lt;Passenger&gt; getPassengers();\n    int getAvailableCapacity() throws NoSuchFieldException;\n}\n</code></pre>"},{"location":"design-smells/design-smell-5/#2-singleflightjourney-implementation","title":"2. SingleFlightJourney Implementation","text":"<p>The <code>SingleFlightJourney</code> class represents a journey with a single direct flight:</p> <pre><code>package flight.reservation.journey;\n\nimport flight.reservation.Airport;\nimport flight.reservation.Passenger;\nimport flight.reservation.flight.ScheduledFlight;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\npublic class SingleFlightJourney implements Journey {\n    private final ScheduledFlight flight;\n\n    public SingleFlightJourney(ScheduledFlight flight) {\n        this.flight = flight;\n    }\n\n    @Override\n    public double getPrice() {\n        return flight.getCurrentPrice();\n    }\n\n    @Override\n    public Airport getDeparture() {\n        return flight.getDeparture();\n    }\n\n    @Override\n    public Airport getArrival() {\n        return flight.getArrival();\n    }\n\n    @Override\n    public Date getDepartureTime() {\n        return flight.getDepartureTime();\n    }\n\n    @Override\n    public Date getArrivalTime() {\n        long estimatedFlightTimeInMillis = calculateEstimatedFlightTime();\n        return new Date(flight.getDepartureTime().getTime() + estimatedFlightTimeInMillis);\n    }\n\n    @Override\n    public List&lt;Airport&gt; getStops() {\n        return new ArrayList&lt;&gt;();\n    }\n\n    @Override\n    public List&lt;ScheduledFlight&gt; getFlights() {\n        return Arrays.asList(flight);\n    }\n\n    @Override\n    public int getTotalDistance() {\n        return calculateDistance(flight.getDeparture(), flight.getArrival());\n    }\n\n    @Override\n    public void addPassenger(Passenger passenger) {\n        flight.addPassengers(Arrays.asList(passenger));\n    }\n\n    @Override\n    public void removePassenger(Passenger passenger) {\n        flight.removePassengers(Arrays.asList(passenger));\n    }\n\n    @Override\n    public List&lt;Passenger&gt; getPassengers() {\n        return flight.getPassengers();\n    }\n\n    @Override\n    public int getAvailableCapacity() throws NoSuchFieldException {\n        return flight.getAvailableCapacity();\n    }\n\n    private long calculateEstimatedFlightTime() {\n        int distance = getTotalDistance();\n        return (long) (distance / 800.0 * 60 * 60 * 1000); // Estimate based on average speed\n    }\n\n    private int calculateDistance(Airport departure, Airport arrival) {\n        return 500; // Simplified implementation\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-5/#3-multiflightjourney-implementation","title":"3. MultiFlightJourney Implementation","text":"<p>The <code>MultiFlightJourney</code> class represents a complex journey with multiple legs:</p> <pre><code>package flight.reservation.journey;\n\nimport flight.reservation.Airport;\nimport flight.reservation.Passenger;\nimport flight.reservation.flight.ScheduledFlight;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class MultiFlightJourney implements Journey {\n    private final List&lt;Journey&gt; journeys = new ArrayList&lt;&gt;();\n    private List&lt;Passenger&gt; passengers = new ArrayList&lt;&gt;();\n\n    public void addJourney(Journey journey) {\n        if (!isValidAddition(journey)) {\n            throw new IllegalArgumentException(\"Cannot add this journey: connections don't match or timing is invalid\");\n        }\n        journeys.add(journey);\n    }\n\n    public void removeJourney(Journey journey) {\n        journeys.remove(journey);\n    }\n\n    @Override\n    public double getPrice() {\n        return journeys.stream().mapToDouble(Journey::getPrice).sum();\n    }\n\n    @Override\n    public Airport getDeparture() {\n        if (journeys.isEmpty()) {\n            return null;\n        }\n        return journeys.get(0).getDeparture();\n    }\n\n    @Override\n    public Airport getArrival() {\n        if (journeys.isEmpty()) {\n            return null;\n        }\n        return journeys.get(journeys.size() - 1).getArrival();\n    }\n\n    @Override\n    public Date getDepartureTime() {\n        if (journeys.isEmpty()) {\n            return null;\n        }\n        return journeys.get(0).getDepartureTime();\n    }\n\n    @Override\n    public Date getArrivalTime() {\n        if (journeys.isEmpty()) {\n            return null;\n        }\n        return journeys.get(journeys.size() - 1).getArrivalTime();\n    }\n\n    @Override\n    public List&lt;Airport&gt; getStops() {\n        if (journeys.size() &lt;= 1) {\n            return new ArrayList&lt;&gt;();\n        }\n\n        List&lt;Airport&gt; stops = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; journeys.size() - 1; i++) {\n            stops.add(journeys.get(i).getArrival());\n        }\n        return stops;\n    }\n\n    @Override\n    public List&lt;ScheduledFlight&gt; getFlights() {\n        return journeys.stream()\n                .flatMap(journey -&gt; journey.getFlights().stream())\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public int getTotalDistance() {\n        return journeys.stream().mapToInt(Journey::getTotalDistance).sum();\n    }\n\n    @Override\n    public void addPassenger(Passenger passenger) {\n        passengers.add(passenger);\n        journeys.forEach(journey -&gt; journey.addPassenger(passenger));\n    }\n\n    @Override\n    public void removePassenger(Passenger passenger) {\n        passengers.remove(passenger);\n        journeys.forEach(journey -&gt; journey.removePassenger(passenger));\n    }\n\n    @Override\n    public List&lt;Passenger&gt; getPassengers() {\n        return passengers;\n    }\n\n    @Override\n    public int getAvailableCapacity() throws NoSuchFieldException {\n        if (journeys.isEmpty()) {\n            return 0;\n        }\n\n        return journeys.stream()\n                .mapToInt(journey -&gt; {\n                    try {\n                        return journey.getAvailableCapacity();\n                    } catch (NoSuchFieldException e) {\n                        return 0;\n                    }\n                })\n                .min()\n                .orElse(0);\n    }\n\n    private boolean isValidAddition(Journey journey) {\n        if (journeys.isEmpty()) {\n            return true;\n        }\n\n        Journey lastJourney = journeys.get(journeys.size() - 1);\n\n        boolean airportsConnect = lastJourney.getArrival().equals(journey.getDeparture());\n        boolean timingIsValid = journey.getDepartureTime().after(lastJourney.getArrivalTime());\n\n        return airportsConnect &amp;&amp; timingIsValid;\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-5/#4-journeyfactory-implementation","title":"4. JourneyFactory Implementation","text":"<p>A factory to create different types of journeys:</p> <pre><code>package flight.reservation.journey;\n\nimport flight.reservation.flight.ScheduledFlight;\n\nimport java.util.List;\n\npublic class JourneyFactory {\n\n    public static Journey createSingleFlightJourney(ScheduledFlight flight) {\n        return new SingleFlightJourney(flight);\n    }\n\n    public static Journey createMultiFlightJourney(List&lt;ScheduledFlight&gt; flights) {\n        MultiFlightJourney multiFlightJourney = new MultiFlightJourney();\n\n        for (ScheduledFlight flight : flights) {\n            multiFlightJourney.addJourney(new SingleFlightJourney(flight));\n        }\n\n        return multiFlightJourney;\n    }\n\n    public static Journey createFromJourneys(List&lt;Journey&gt; journeys) {\n        MultiFlightJourney multiFlightJourney = new MultiFlightJourney();\n\n        for (Journey journey : journeys) {\n            multiFlightJourney.addJourney(journey);\n        }\n\n        return multiFlightJourney;\n    }\n}\n</code></pre>"},{"location":"design-smells/design-smell-5/#benefits-of-the-implementation","title":"Benefits of the Implementation","text":"<ol> <li> <p>Unified Interface: Both simple and complex journeys can be treated through the same interface.</p> </li> <li> <p>Simplified Client Code: Client code can work with journeys without knowing whether they're dealing with a single flight or a multi-leg journey.</p> </li> <li> <p>Recursive Composition: Complex journeys can be built from both single flights and other complex journeys.</p> </li> <li> <p>Automatic Calculations: Properties like total price, travel time, and distance are calculated automatically for complex itineraries.</p> </li> <li> <p>Simplified Passenger Management: Passengers can be added or removed from an entire journey with a single operation.</p> </li> <li> <p>Connection Validation: The <code>MultiFlightJourney</code> class validates that connections make sense (airports match and times align).</p> </li> <li> <p>Extensibility: New journey types can be added by implementing the <code>Journey</code> interface.</p> </li> </ol>"},{"location":"design-smells/design-smell-5/#example-usage","title":"Example Usage","text":"<pre><code>// Create airports and flights\nAirport nyc = new Airport(\"JFK\", \"JFK\", \"New York\");\nAirport lhr = new Airport(\"Heathrow\", \"LHR\", \"London\");\nAirport cdg = new Airport(\"Charles de Gaulle\", \"CDG\", \"Paris\");\n\nScheduledFlight nycToLhr = new ScheduledFlight(101, nyc, lhr, aircraft, departureTime1);\nScheduledFlight lhrToCdg = new ScheduledFlight(202, lhr, cdg, aircraft, departureTime2);\n\n// Create a simple direct journey\nJourney directFlight = JourneyFactory.createSingleFlightJourney(nycToLhr);\n\n// Create a complex journey with connecting flights\nJourney connectingFlight = JourneyFactory.createMultiFlightJourney(Arrays.asList(nycToLhr, lhrToCdg));\n\n// Or build it step by step\nMultiFlightJourney customJourney = new MultiFlightJourney();\ncustomJourney.addJourney(new SingleFlightJourney(nycToLhr));\ncustomJourney.addJourney(new SingleFlightJourney(lhrToCdg));\n\n// Work with journeys uniformly\nSystem.out.println(\"Direct flight price: \" + directFlight.getPrice());\nSystem.out.println(\"Connecting flight price: \" + connectingFlight.getPrice());\n\nSystem.out.println(\"Direct flight stops: \" + directFlight.getStops().size());\nSystem.out.println(\"Connecting flight stops: \" + connectingFlight.getStops().size());\n\n// Add a passenger to the entire journey\nPassenger passenger = new Passenger(\"John Doe\");\nconnectingFlight.addPassenger(passenger);\n</code></pre>"},{"location":"design-smells/design-smell-5/#trade-offs","title":"Trade-offs","text":""},{"location":"design-smells/design-smell-5/#advantages","title":"Advantages","text":"<ol> <li> <p>Simplified Client Code: The Composite Pattern simplifies client code by providing a unified way to work with both simple and complex structures.</p> </li> <li> <p>Recursive Composition: The pattern allows for recursive composition, enabling complex hierarchies to be built.</p> </li> <li> <p>Extensibility: New journey types can be easily added without changing existing code.</p> </li> <li> <p>Operation Distribution: Operations applied to composite objects are automatically distributed to all components.</p> </li> </ol>"},{"location":"design-smells/design-smell-5/#disadvantages","title":"Disadvantages","text":"<ol> <li> <p>Component Constraints: Sometimes components in a composite structure need different behaviors, which can be difficult to handle through a common interface.</p> </li> <li> <p>Performance Overhead: For very large composite structures, there could be performance overhead when traversing the entire structure.</p> </li> <li> <p>Design Complexity: The pattern adds a layer of abstraction, which may increase design complexity for simple use cases.</p> </li> <li> <p>Validation Challenges: Ensuring that all components in a composite structure maintain valid relationships can be challenging.</p> </li> </ol>"}]}